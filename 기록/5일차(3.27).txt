코틀린 5일차
<<람다>>
- 장점: 편리하고 간결함, 함수를 변수에 할당할 수 있음
- 형태: 파라미터 -> 함수 내용
- 변수에 할당하는 경우: var 변수 이름: 함수의 자료형 = { 람다 }
- 타입 추론 가능
- 파라미터와 반환값이 모두 없다면: () -> Unit // Unit 객체 반환
- 람다는 실행될 때마다 객체가 생성되기 때문에 메모리 측면에서 비효율적
  inline 키워드: 함수를 호출할 때 해당 함수의 내용을 바이트코드로 변환해 본문에 삽입
  = 호출 지점에 inline 되는 것
  uninline: 어떤 람다는 인라인을 하고 싶지 않을 경우
- 람다에는 return, break, continue 사용 불가능
  (대신 return의 경우 가장 마지막 라인을 반환값으로 간주)
- 그래서 익명 함수를 사용
- 함수 호출 시 파라미터가 하나라면 함수 이름 뒤에 바로 람다를 쓸 수 있음(소괄호 생략 가능)
  ex) 함수(~파라미터 함수~) 대신 함수 람다 로 쓸 수 있음

<<제어문>>
- if: 코틀린에서는 변수에 넣는 것도 가능
  ex) var a = if ~ else
- when: switch와 비슷
        when(변수) { 값 -> 코드 값 -> 코드 else -> 코드 }
- for
  기본적인 형태: for (i: Int in 1..10) // in 키워드: 값의 범위를 정의, 자료형 생략 가능!
  증가값을 지정: for (i in 1..10 step 2) // step 키워드(음수는 불가능)
  역순: for (i in 10 downTo 1)
  미만: for (i in 1 until 10) // 1..9

<<클래스와 인스턴스>>
- 클래스: 객체를 만들어 내는 틀= 프로토타입을 만드는 것!
- 선언: class 클래스 이름 {} // 기본 접근 제한자는 public!
- 클래스 안에 들어가는 변수는 속성(property), 함수는 메서드(method)라고 부름
- 객체를 만들고 점 연산자(.)를 이용해 클래스 내의 멤버들에 접근할 수 있음
- 객체 생성: 클래스 이름() // 자바와는 달리 new 연산자를 이용하지 않음
- 인스턴스: 클래스로부터 만들어진 객체

<<생성자>>
- 객체가 만들어질 때 자동으로 호출되는 함수

<주생성자>
- 클래스를 정의할 때 기본적으로 만들어지는 생성자 함수
- class 클래스 이름(여기가 생성자 부분<파라미터>)
  class 클래스 이름 constructor() // 원래는 이건데 constructor 생략된 거!
  다만 클래스가 annotation이나 private으로 정의될 경우 생략 불가능
  파라미터를 적을 때 var/val을 붙이면 클래스 내부에서 변수를 선언하지 않아도 자동으로 해 줌!
  안 붙이면 그냥 값만을 전달받겠다는 의미이므로 선언도 해 주고 초기화도 해 주어야 함
  다른 파라미터와 같이 기본값도 지정 가능!
  ex) class Bus (var name: Int, var interval: String) {} // 선언과 동시에 초기화
      class Bus (name: Int, interval: String) { var name: Int = name var ~~ } // var 안 붙이면 요렇게
- 생성자가 호출될 때 별도로 기능을 추가하고 싶다면 init 키워드를 이용
  init { 기능 } // 보통 여기에서 프롬프트를 출력하거나 유효성 등을 검사함

<부생성자>
- 생성자를 따로 정의하고 싶을 때 사용
- constructor 키워드 꼭 써 주어야 함!
- 주생성자처럼 멤버 변수 선언은 못함
- 다중정의 가능(대신 파라미터의 자료형과 개수가 달라야 함)
- 주생성자가 존재할 경우 꼭 호출해 주어야 함!
  ex) class Bus(name: Int)
      constructor(name: Int, interval: String): this(name) { this.interval = interval }
      constructor(name: Int, interval: String, color: String): this(name, interval) { this.color = color }
      주생성자가 name만을 파라미터로 가지므로,
      첫 번째 부생성자에서는 name을 초기화 하는 것은 주생성자에 위임하고 interval만 초기화
      두 번째 부생성자는 파라미터 3개 중 2개를 첫 번째 부생성자를 이용해 초기화할 수 있으므로 호출 -> 물론 간접적으로는 주생성자를 호출하게 됨

<<상속>>
- 어떤 클래스의 기능을 확장하고자 할 때(이미 정의된 것을 사용하는 게 효율적이니까!)
- 모든 클래스는 암시적 또는 묵시적으로 Any 클래스를 상속함
- 부모 클래스(= 상위 클래스)는 class 앞에 open 키워드를 가져야 함 -> 안 그러면 오류 발생
- 상속하는 코드: class 자식 클래스(<파라미터>): 부모 클래스()
  저 부모 클래스 부분이 생성자를 호출하는 부분!
- 상속된 메서드는 재정의할 수도 있음: override 키워드 사용(부모 클래스의 함수에는 open)

<<복습: 버스 객체 만들기>>
- 오늘 공부한 내용을 어떻게든 활용하려고 만든 거라 개연성이 없음
- 사용자는 두 가지의 버스를 만들 수 있음(일반버스, 전기버스) -> 상속 이용
- 버스는 네 개의 멤버 변수(이름, 배차 간격, 색상, 속도)와 한 개의 메서드(운행하다)를 가짐
- 버스를 만들면 운행할 수 있음: 초기 속도를 설정하는 drive()
  일반버스의 경우 50, 전기버스는 60 -> 메서드 오버라이딩
- 가속은 전기버스밖에 못함 -> 자식 클래스의 고유한 메서드

1 사용자에게서 버스 이름과 배차 간격, 색상을 입력받음
  역시 입력이 옳지 않을 경우(fun isValid(): Boolean) 토스트 메시지 출력(일일이 작성하기 귀찮아서 showToast 함수 생성함)
2 버스 객체 생성 -> 이 부분도 귀찮아서 createBus(Int)로 한 번에 처리
  파라미터: 일반버스(0) 전기버스(1)
3 하나의 함수로 서로 다른 객체를 생성할 수 있어야 하므로 람다 배열 이용함
  하지만 Bus와 ElectricBus는 엄연히 자료형이 다르므로 배열의 자료형은 Any
  (사실 안 될 줄 알았는데 돼서 놀랐다.. 다른 성격의 함수들을 묶어서 한 번에 처리 가능한 게 신기)
4 여기까지 왔으면 일단 버스 객체가 생성되었을 것이므로 as 연산자를 이용해 버스 객체를 갖고옴
5 운행 속도를 0으로 초기화하고 노선이 추가되었다는 토스트 메시지 출력
  여기서 이 버스가 전기버스라면 전기버스라고 출력 -> 이건 if (bus is ElectricBus) 이용함!
  bus는 Bus지만 ElectricBus는 아니기 때문에 자연스레 걸러짐
6 밑에 있는 운행 시작 버튼과 가속 버튼의 경우 버스가 없으면 작동하지 않음
  if (bus is Bus) {} else { 버스 없음! }
  (여기서 lateinit bus 초기화 안 한 것 때문에 고생 좀 했다..
   버스 객체가 없으면 bus는 Bus가 아닐 테니 null이 반환될 텐데 왜 안 되지 했는데
   애초에 lateinit이 초기화되지 않아서 발생한 문제였음)
7 가속 버튼은 전기버스일 때만 작동함(속도 제한: 200)
  if (bus as? Bus == null) { 버스 없음! }
  else if (bus is ElectricBus) { 가속! }
  else { 일반버스는 가속 못함! }
  6번과 코드가 살짝 다른 이유는 저렇게 하면 일반버스랑 전기버스랑 같이 걸러져서 에러가 발생할 수 있기 때문
  그래서 null을 먼저 거름
  생각해 보니 if (bus is ElectricBus) / else if (bus is Bus) / else 이렇게 해도 괜찮을 듯

<<오류사항>>
1 클래스 이름은 대문자로 시작하는 것이 좋음
2 Missing accessibility label
  인풋과 설명을 위한 텍스트가 있을 때 두 개를 연결해 주지 않아서 발생
  인풋의 아이디를 텍스트에서 android:labelFor="id"와 같이 적어 주면 됨
3 UninitializedPropertyAccessException
  lateinit으로 선언된 변수를 초기화하지 않고 접근하려 할 경우
4 mutable property that could have been changed by this time
  Any로 선언된 bus 변수에 객체를 할당해서 멤버 변수에 접근하려 하니 안 된다 함
  혹시나 해서 if (bus is Bus)를 추가했는데도 여전히 오류
  아마 컴파일 시점에서는 이게 버스 객체인지 알 수 없어서 그런 듯함
  (Any의 자료형은 바뀌지 않는 듯..? 임의의 자료형을 대입해도 일단은 Any로 취급)

<<메모>>
- 아 졸려
- Any를 이렇게 활용해도 되는지에 대한 걸 찾아봐야 할 듯
- 람다 쓰는 게 나름 재미있다
- 버스에 대해 개선하면 좋을 것 같은 점들
  1 버스 목록(생성과 삭제)
  2 노선도 제작(?)
  3 버스 이미지
- 상속 공부 더 하기

