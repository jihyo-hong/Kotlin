코틀린 4일차
<<함수>>
- 정해진 기능을 수행
- fun 함수이름(파라미터): 반환 타입 {}
- 반환값이 없는 경우 반환 타입 부분은 생략 가능
  ex) fun add(a: Int, b: Int): Int { return a + b }
      fun add(a: Int, b: Int): Int = a + b // 코드가 한 줄일 땐 생략 가능
      fun add(a: Int, b: Int) = a + b // 반환 타입을 유추할 수 있으므로 생략 가능
- 파라미터에 기본값을 할당할 수 있음
  그러면 함수 호출 시 모든 값을 전달할 필요가 없음
- 함수 호출 시 파라미터에 이름을 붙일 수도 있음
  1 기존의 정의한 순서와 상관없이 값을 알맞게 전달 가능
  2 파라미터의 기본값을 덮어 씌울 수 있음
  ex) fun add(a: Int= 100, b: Int= 200) = a + b
      add(b= 300, a= 200) // 200 + 300
      add(b= 50) // 100 + 50
      add(50) // add(a= 50)과 같음!
- 가변 파라미터: 파라미터의 개수가 정해지지 않음
  vararg 변수 이름: 자료형
  함수 내부에서는 배열로 전달됨
  호출할 때 배열을 이용하고 싶다면 앞에 *(spread operator) 붙이면 됨!

<<일급 객체>>
1 변수에 할당할 수 있어야 함
2 함수 호출 시 파라미터로 전달할 수 있어야 함
3 함수에서 반환될 수 있어야 함
- 코틀린에서 함수는 일급 객체임(변수처럼 사용 가능)
- 변수에 함수를 할당하는 두 가지 방법: 익명 함수, 람다식
- 이때 변수에 함수가 담기는 것이 아니라 변수가 함수를 가리킨다고 보는 것이 맞음

<<람다식>>
- 함수의 축약 형태
- 중괄호 안에 실행 코드가 들어간 익명 함수라고 할 수 있음
- { 실행될 문장 } ex) var add = { x: Int, y: Int -> x + y }
- var add: (Int, Int) -> Int = { x, y -> x + y } // 이렇게도 가능!
- 함수를 파라미터로 넘길 수 있음
  파라미터에서의 자료형은? (Int, Int) -> Int // 딱 자료형만 보면 됨
- 이렇게 하면 함수 배열을 만들어서 반복문으로 한 번에 돌릴 수 있음
- 람다식을 이용해 결과값으로 함수를 반환할 수도 있음

<<복습: 계산기 수정!>>
- 어제의 코드는 중복되는 부분이 많았음
  (각각의 연산마다 유효성 검사 + 계산 + 출력하는 부분이 있었으므로)
  그래서 이 부분들을 함수로 처리하기로 함

- 유효성 검사: fun isValid(a: String, b: String): Int
  입력된 두 개의 문자열을 파라미터로 받아서 유효성을 판단한 후 종료 코드 반환
  0: 입력이 하나인 경우, 숫자가 아닌 경우
  1: 유효한 경우
  이 반환된 종료 코드에 따라 다음 연산을 수행할지 여부가 결정됨

- 계산: var execute: Array<(Int, Int) -> Int> = { ~람다~ }
  함수를 변수처럼 활용할 수 있다면, 함수를 배열로 돌리는 것도 가능하다는 것
  지금은 정수형만 처리할 생각이므로 배열의 타입은 (Int, Int) -> Int형임
  그다음 덧셈, 뺄셈, 곱셈, 나눗셈의 네 가지 람다식으로 초기화
  이 배열에서 함수를 호출할 때 인덱스를 이용해야 하므로
  xml 코드의 hint 속성 부분에 순서대로 0, 1, 2, 3의 고유값을 설정하면 이를 인덱스로 활용할 수 있음
  (되는 건가 좀 긴가민가 하긴 했지만 되더라)
  그냥 kt 코드에다가 냅다 0 1 2 3 해도 될 것 같긴 한데..
  특징이 드러나게 하려면 속성을 쓰는 게 맞음

= 따라서, 사용자가 네 가지 연산 중 하나의 버튼을 눌렀을 때
  if (값이 유효한가?)
      유효하다면 execute[연산의 고유값] 실행!
  으로 코드를 간결하게 줄일 수 있음!

<<메모>>
- 람다 복습하기,,