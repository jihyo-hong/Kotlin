코틀린 6일차
<<인터페이스>>
- 캡슐화: 필요한 기능만 외부로 노출시키고 나머지는 숨김(정보 은닉)
- 객체를 만들 때 필요한 지침 같은 것(이런 기능들이 꼭 들어가야 해!)
- 내용이 없는 클래스
- 함수는 내부 매커니즘 구현 가능
- 객체를 생성할 수는 없지만 자료형으로 다룰 수 있음
  인터페이스형 배열을 선언해서 해당되는 객체들에 대해 함수를 실행할 수도 있음
  (생각해 보니 클래스의 상속관계에서 배열을 돌릴 때에도 굳이 일반버스니 전기버스니 구분할 필요는 없던 듯
   실행 시 실제로 들어 있는 객체에게 함수를 호출하니까)
- 그럼 클래스 쓰면 되지 왜 인터페이스를 쓰냐?
  1 코틀린에서 클래스는 하나만 상속할 수 있음 -> 다중 상속
  2 인터페이스는 내부에 정의한 변수/함수에 대해 구현을 강요함
  3 (개인적인 의견) 클래스는 따로 설명하지 않으면 많은 클래스 중 하나일 뿐이지만 인터페이스는 그 자체로 의미가 있음
  4 클래스 간의 의존성 감소

<속성 property>
- 필드(값이 저장된 부분) + 메서드(getter + setter)
- 캡슐화의 관점에서, 필드 부분은 private으로 두고 접근 메서드를 이용하는 게 일반적
  (그러므로 변경이 불가능한 val 변수의 경우는 setter 메서드가 없음)
- 자바와 달리 코틀린은 변수를 선언하면 get(), set() 메서드를 자동으로 정의해 줌
- 즉 클래스의 외부에서 변수에 접근하면 내부적으로는 get() 메서드를 통해 필드에 접근하는 메커니즘
- 커스텀 가능함!
  ex) val a: Int
          get() = 어쩌고~ // 어떠한 연산의 결과를 반환하는 것이므로 중괄호도 가능함

<<추상 클래스>>
- 구체화되지 않은 클래스(= 어떤 기능들은 나중에 구현하고 싶을 때, 말 그대로 추상적!)
- 객체 생성 불가능
- abstract 키워드 이용
- 해당 키워드가 붙은 변수나 함수는 하위 클래스에서 꼭 오버라이딩 해 주어야 함

<<익명 클래스>>
- 한 번만 사용할 객체를 위해 매번 클래스를 작성하는 것은 비효율적
- UI 이벤트 처리, 스레드 객체...
- object: <추상 클래스 이름 또는 인터페이스> { 오버라이딩할 메서드나 변수 }
- 이 클래스로부터 만들어지는 객체는 무명 객체라고 함
- 메서드를 새로 정의할 시 외부에서 사용 불가능

<상속 변경 제어자>
- open: 상속 가능!
- final: 상속 불가능(기본값)
- 자바의 클래스는 기본적으로 open이고, 상속을 비허용할 때에만 final을 붙이도록 했음
- 이러다 보니 무분별한 상속이 일어날 경우 취약한 기반 클래스(fragile base class) 문제가 발생
  (불필요한 게 상속되거나 메서드 오버라이딩 시 부모 클래의 호출 방법에 영향을 받거나,
   부모 클래스의 수정사항이 자식 클래스에게 영향을 미치는 등)
  이를 캡슐화가 깨지고 결합도가 높아진다고 표현한다
- abstract: 추상 클래스 정의
            클래스 내에 abstract 멤버가 하나라도 있다면 클래스도 그렇게 정의해야 함
            open은 안 써도 됨!

<<접근 제한자>>
- public: 모든 곳에서 접근 가능(기본값. 자바의 default 키워드와 같음)
- private: 같은 파일 내에서만 접근 가능
- protected: 클래스 자신과 상속받은 클래스에서만 접근 가능(패키지 선언에는 안 쓰임)
- internal: 같은 모듈 내에서만 접근 가능
            (모듈: 여러 코틀린 파일들이 한 번에 컴파일된 것)

<<메인 액티비티>>
- onCreate <-> onDestroy: 생명주기(수명주기) 메서드
- res 폴더 = R?
- OnClickListener 인터페이스?
  onClick 메서드 가지고 있음

<<오류사항>>
1 <> is already running. if that is not the case delete the files at ~
  아마 xml에 에러가 남아 있는 상태(missing constraints)로 실행해서 그런 듯
  *.load 파일도 삭제해 보고 껐다 켜는 것도 해봤는데 안 되다가 마법봉 누르고 해결

<<메모>>
- 컴파일 할 때 실제 객체가 무엇인지에 따라서 호출되는 게 다른가?
